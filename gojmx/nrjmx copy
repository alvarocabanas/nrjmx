package nrjmx

import (
	"context"

	"time"

	"github.com/apache/thrift/lib/go/thrift"
	"github.com/newrelic/nrjmx/nrprotocol"
)

func NewJMXServiceClient(ctx context.Context) (client *JMXClient, err error) {
	jmxProcess, err := startJMXProcess(ctx)
	if err != nil {
		return
	}

	var protocolFactory thrift.TProtocolFactory
	protocolFactory = thrift.NewTCompactProtocolFactory()

	var transportFactory thrift.TTransportFactory
	// transportFactory = thrift.NewTTransportFactory()

	// pr, pw := io.Pipe()

	// // var buf bytes.Buffer
	// x := io.TeeReader(jmxProcess.Stdout, pw)

	// go func() {
	// 	for {
	// 		buf := make([]byte, 1)

	// 		x.Read(buf)
	// 		fmt.Fprintf(os.Stdout, "%s", buf)
	// 	}
	// }()

	transportFactory = thrift.NewTBufferedTransportFactory(8192)

	transportFactory = thrift.NewTFramedTransportFactory(transportFactory)

	var transport thrift.TTransport

	transport = thrift.NewStreamTransport(jmxProcess.Stdout, jmxProcess.Stdin)
	transport, err = transportFactory.GetTransport(transport)
	if err != nil {
		return nil, err
	}

	iprot := protocolFactory.GetProtocol(transport)
	oprot := protocolFactory.GetProtocol(transport)
	client = &JMXClient{
		JMXService: nrprotocol.NewJMXServiceClient(thrift.NewTStandardClient(iprot, oprot)),
		jmxProcess: *jmxProcess,
		ctx:        ctx,
	}
	return
}

type JMXClient struct {
	nrprotocol.JMXService
	jmxProcess jmxProcess
	ctx        context.Context
}

func (j *JMXClient) Close(timeout time.Duration) error {
	j.Disconnect(j.ctx)
	return j.jmxProcess.stop(timeout)
}
